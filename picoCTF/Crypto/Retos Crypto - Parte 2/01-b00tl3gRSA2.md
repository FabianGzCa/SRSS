## Objetivo
In RSA d is a lot bigger than e, why don't we use d to encrypt instead of e? Connect with nc jupiter.challenges.picoctf.org 18243.

## Solución
Nos dan lo siguiente:
```bash
c: 66929325550180390547157066271654612744712402491736963906855370074577189097364008195528118767810931599411121180199681168055123983028303951651878469980494814866596676808708842565616887770376285397980278097650435880619319708456321520993197542338494103798465777519391903124920346811251648872604909886878998421905
n: 69659999909213652891738705885790963083652209238946066732398718109324977660950850251453559492171516654550438634197168087261078983761805141433501649461081430527125385219959082304830731789644610362739902076197334853072889438701236607609615112967290045576119897538367611853858610876615542912416110817245766168571
e: 50864544236927386750709736964747253420283089261341304567072161624786570654548453361201437904365103040829709788377119514896801405144230331540332757576797686357953297692689115800460729354290438493956162767661134987134013131775338969042142150101850581289062909995379902019054884575797171715612433632249265817473
```
Utilizamos el siguiente script de python:
```python
c = int(input("c: "))
n = int(input("n: "))
d = int(input("d: "))
e = 65537

# Realiza la operación de potencia modular
r = pow(c, e, n)

# Convierte el valor entero a hexadecimal sin el prefijo '0x' y luego a bytes
hex_string = hex(r)[2:]  # Elimina el '0x' del inicio

# Si la longitud es impar, añade un 0 al inicio
if len(hex_string) % 2 != 0:
    hex_string = '0' + hex_string

# Convierte el hexadecimal a bytes y luego a caracteres (UTF-8)
decoded_message = bytes.fromhex(hex_string).decode('utf-8', errors='replace')

print(decoded_message)
```
y nos imprime la flag
picoCTF{bad_1d3a5_4783252}

## Notas Adicionales


## Referencias
https://github.com/RsaCtfTool/RsaCtfTool